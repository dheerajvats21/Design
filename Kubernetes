1. https://www.youtube.com/watch?v=B_X4l4HSgtc - pos container

2. https://www.youtube.com/watch?v=klxZke9qbvg - planes and arcitecture

3. EKS - https://www.youtube.com/watch?v=CukYk43agA4&t=49s


                      ┌───────────────┐
                      │   kubectl /   │
                      │  API Clients  │
                      └───────┬───────┘
                              │
                              ▼
                     ┌───────────────────┐
                     │   API Server      │   (Control Plane)
                     └───┬─────┬────────┘
                         │     │
        ┌────────────────┘     └───────────────┐
        ▼                                      ▼
 ┌───────────────┐                      ┌───────────────┐
 │     etcd      │                      │   Scheduler   │
 │ (Cluster DB)  │                      │  (assigns)    │
 └───────┬───────┘                      └───────┬───────┘
         │                                      │
         ▼                                      ▼
 ┌───────────────┐                      ┌───────────────┐
 │ Controller    │                      │  Node / Data  │
 │ Manager       │                      │   Plane       │
 └───────┬───────┘                      └───────────────┘
         │
         ▼
 ┌────────────────────────────────────────────────────┐
 │                 Data Plane (Worker Nodes)          │
 │                                                    │
 │   ┌──────────┐    ┌──────────────┐    ┌─────────┐ │
 │   │  Kubelet │ →  │ Container    │ ←→ │ Runtime │ │
 │   │  (agent) │    │ (Pod Mgmt)   │    │ (CRI)   │ │
 │   └──────────┘    └──────────────┘    └─────────┘ │
 │          │                                        │
 │          ▼                                        │
 │     ┌──────────┐                                  │
 │     │ Kube-proxy│ ←── Service Networking ──────→  │
 │     └──────────┘                                  │
 └────────────────────────────────────────────────────┘


Once we have pods (groups of containers running together), we need a system that ensures:

They get scheduled onto some node.

They can be reached via networking.

They scale, recover, and stay consistent.

This is where Kubernetes’ planes come in.

🔹 1. Control Plane

The control plane is the “brain” of Kubernetes. It manages the overall cluster state. Think of it as the management layer.

Key Components:

API Server (kube-apiserver)

Acts as the front door of Kubernetes.

Every request (from kubectl, controllers, nodes) goes through it.

Validates & authenticates requests, updates cluster state in etcd.

etcd

A distributed key-value store.

Stores all cluster state (pods, deployments, configs, secrets).

Highly available, consistent database → critical for Kubernetes.

Controller Manager

Runs various controllers (loops) that watch actual state vs desired state.

Example: Deployment controller ensures the number of pods = replicas you asked for.

If a pod dies, controller spins up a replacement.

Scheduler

Decides which node runs a pod.

Looks at constraints: CPU, memory, taints/tolerations, affinities.

Doesn’t start pods itself — just binds pods to nodes.

Cloud Controller Manager (in cloud setups)

Integrates Kubernetes with cloud providers (AWS, GCP, Azure).

Example: Creates a cloud load balancer if you make a LoadBalancer service.

🔹 2. Data Plane

The data plane lives on the worker nodes. This is where actual workloads (pods/containers) run.

Key Components:

Kubelet

Agent running on every node.

Talks to the control plane.

Ensures the containers defined in PodSpecs are actually running.

Reports node + pod status back to API server.

Kube-proxy

Handles networking/routing inside the cluster.

Implements Services (ClusterIP, NodePort, LoadBalancer) by managing IP tables / IPVS.

Ensures pods can reach each other and external clients can reach services.

Container Runtime

Runs the containers (Docker, containerd, CRI-O).

Kubernetes is runtime-agnostic as long as it supports the CRI (Container Runtime Interface).

🔹 3. Planes in Action (Flow Example)

Let’s say you apply a Deployment for 3 replicas of an app:

kubectl apply -f deploy.yaml → goes to API Server.

API Server writes desired state into etcd.

Controller Manager sees: “Deployment needs 3 pods, but none exist.” → creates 3 Pod objects.

Scheduler picks nodes for those pods based on resources.

Kubelet on each chosen node sees “I need to run this pod” → pulls container image, starts it via container runtime.

Kube-proxy ensures networking → pod gets a cluster IP, can talk to others.

If one pod dies, controller notices, asks for a new one → Scheduler assigns, Kubelet runs it.

That’s how the control plane manages state, and the data plane executes it.

🔹 4. Interview Insights

If control plane goes down → cluster state can’t change (no new pods, no scaling), but existing workloads keep running.

If data plane node goes down → pods there are lost. Controller reschedules them on healthy nodes.

Separation of planes = resilience + scalability.

✅ Summary in one line:
The control plane is the brain (decides desired state, schedules, stores state), while the data plane is the body (

